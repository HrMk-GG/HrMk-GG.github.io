<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>極・3D MINECRAFT</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; touch-action: none; background: #000; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.8);
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::before { content: ''; position: absolute; top: 9px; left: 0; width: 20px; height: 2px; background: white; }
        #crosshair::after { content: ''; position: absolute; top: 0; left: 9px; width: 2px; height: 20px; background: white; }

        /* UI Overlays */
        .ui-panel { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box; pointer-events: none; z-index: 20; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 8px; pointer-events: auto; }
        .action-group { display: flex; flex-direction: column; gap: 15px; pointer-events: auto; }
        
        .btn {
            width: 60px; height: 60px; background: rgba(0, 0, 0, 0.4);
            border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 20px; font-weight: bold; user-select: none;
            backdrop-filter: blur(4px);
        }
        .btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        .btn-wide { width: 130px; font-size: 16px; border-color: #ffd700; }
        .btn-jump { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    
    <div class="ui-panel">
        <div class="d-pad">
            <div></div><div class="btn" id="up">▲</div><div></div>
            <div class="btn" id="left">◀</div><div class="btn btn-jump" id="jump">J</div><div class="btn" id="right">▶</div>
            <div></div><div class="btn" id="down">▼</div><div></div>
        </div>
        <div class="action-group">
            <div class="btn btn-wide" id="add">BLOCK PLACE</div>
            <div class="btn btn-wide" id="rem">BLOCK BREAK</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 初期設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x73C2FB);
        scene.fog = new THREE.Fog(0x73C2FB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- テクスチャ生成 (Canvasでドット絵を作る) ---
        function createTexture(color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1; ctx.fillRect(0,0,16,16);
            for(let i=0; i<32; i++){
                ctx.fillStyle = color2;
                ctx.fillRect(Math.random()*16, Math.random()*16, 2, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; // ドットをクッキリさせる
            return tex;
        }

        const grassTex = createTexture('#5ead3a', '#4e8d2f');
        const dirtTex = createTexture('#8b4513', '#5d2e0d');
        const grassMat = new THREE.MeshLambertMaterial({ map: grassTex });
        const dirtMat = new THREE.MeshLambertMaterial({ map: dirtTex });

        // --- ワールド生成 ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const blocks = [];
        for (let x = -15; x < 15; x++) {
            for (let z = -15; z < 15; z++) {
                const b = new THREE.Mesh(geometry, grassMat);
                b.position.set(x, 0, z);
                scene.add(b); blocks.push(b);
            }
        }

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(10, 20, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        camera.position.set(0, 2, 5);
        let yVelocity = 0;
        let isGrounded = true;

        // --- 操作ロジック ---
        let move = { f:0, b:0, l:0, r:0 };
        const lookSpeed = 0.006;
        let lastX, lastY;

        window.addEventListener('touchstart', e => { 
            if(e.target.tagName === 'CANVAS'){ lastX = e.touches[0].pageX; lastY = e.touches[0].pageY; }
        });
        window.addEventListener('touchmove', e => {
            if(e.target.tagName === 'CANVAS'){
                const dx = e.touches[0].pageX - lastX;
                const dy = e.touches[0].pageY - lastY;
                camera.rotation.y -= dx * lookSpeed;
                camera.rotation.x -= dy * lookSpeed;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                lastX = e.touches[0].pageX; lastY = e.touches[0].pageY;
            }
        });

        const bind = (id, k) => {
            const el = document.getElementById(id);
            el.ontouchstart = (e) => { e.preventDefault(); move[k] = 1; };
            el.ontouchend = () => move[k] = 0;
        };
        bind('up','f'); bind('down','b'); bind('left','l'); bind('right','r');
        
        document.getElementById('jump').ontouchstart = () => { if(isGrounded){ yVelocity = 0.15; isGrounded = false; } };

        // ブロック操作
        const ray = new THREE.Raycaster();
        const center = new THREE.Vector2(0,0);
        const op = (type) => {
            ray.setFromCamera(center, camera);
            const hits = ray.intersectObjects(blocks);
            if(hits.length > 0){
                const h = hits[0];
                if(type === 'add'){
                    const nb = new THREE.Mesh(geometry, dirtMat);
                    nb.position.copy(h.object.position).add(h.face.normal);
                    scene.add(nb); blocks.push(nb);
                } else if(h.object.position.y !== 0){
                    scene.remove(h.object); blocks.splice(blocks.indexOf(h.object), 1);
                }
            }
        };
        document.getElementById('add').ontouchstart = (e) => { e.preventDefault(); op('add'); };
        document.getElementById('rem').ontouchstart = (e) => { e.preventDefault(); op('rem'); };

        // --- ループ ---
        function animate() {
            requestAnimationFrame(animate);
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

            const s = 0.12;
            if(move.f) camera.position.addScaledVector(dir, s);
            if(move.b) camera.position.addScaledVector(dir, -s);
            if(move.l) camera.position.addScaledVector(side, s);
            if(move.r) camera.position.addScaledVector(side, -s);

            // 重力
            yVelocity -= 0.008;
            camera.position.y += yVelocity;
            if(camera.position.y < 2){ camera.position.y = 2; yVelocity = 0; isGrounded = true; }

            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
