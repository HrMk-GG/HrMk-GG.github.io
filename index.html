<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D MiniCraft Mobile - RTX 4060 Power</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; touch-action: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 15px; height: 15px; border: 2px solid white; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        /* 操作パネル */
        .ui-overlay {
            position: absolute; bottom: 20px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box; pointer-events: none; z-index: 20;
        }
        .joy-pad {
            display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px);
            gap: 5px; pointer-events: auto;
        }
        .action-btns {
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        .btn {
            width: 50px; height: 50px; background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; user-select: none;
        }
        .btn:active { background: rgba(255, 255, 255, 0.6); }
        .wide { width: 110px; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    
    <div class="ui-overlay">
        <div class="joy-pad">
            <div></div><div class="btn" id="btn-up">↑</div><div></div>
            <div class="btn" id="btn-left">←</div><div></div><div class="btn" id="btn-right">→</div>
            <div></div><div class="btn" id="btn-down">↓</div><div></div>
        </div>
        <div class="action-btns">
            <div class="btn wide" id="btn-add">置く</div>
            <div class="btn wide" id="btn-rem">壊す</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 基本設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 地面 ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x7cfc00 });
        const dirtMat = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const blocks = [];

        for (let x = -8; x < 8; x++) {
            for (let z = -8; z < 8; z++) {
                const mesh = new THREE.Mesh(geometry, grassMat);
                mesh.position.set(x, 0, z);
                scene.add(mesh);
                blocks.push(mesh);
            }
        }
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.set(0, 2, 5);

        // --- スマホ用変数 ---
        let move = { f: false, b: false, l: false, r: false };
        let rotation = { x: 0, y: 0 };
        const lookSpeed = 0.005;

        // --- タッチ視点移動 ---
        let lastTouchX, lastTouchY;
        window.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'CANVAS') {
                lastTouchX = e.touches[0].pageX;
                lastTouchY = e.touches[0].pageY;
            }
        });
        window.addEventListener('touchmove', (e) => {
            if (e.target.tagName === 'CANVAS') {
                const dx = e.touches[0].pageX - lastTouchX;
                const dy = e.touches[0].pageY - lastTouchY;
                camera.rotation.y -= dx * lookSpeed;
                camera.rotation.x -= dy * lookSpeed;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                lastTouchX = e.touches[0].pageX;
                lastTouchY = e.touches[0].pageY;
            }
        });

        // --- ボタンイベント ---
        const setupBtn = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); move[key] = true; });
            el.addEventListener('touchend', () => move[key] = false);
        };
        setupBtn('btn-up', 'f'); setupBtn('btn-down', 'b');
        setupBtn('btn-left', 'l'); setupBtn('btn-right', 'r');

        // --- ブロック操作 ---
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);

        const handleBlock = (mode) => {
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(blocks);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (mode === 'add') {
                    const b = new THREE.Mesh(geometry, dirtMat);
                    b.position.copy(intersect.object.position).add(intersect.face.normal);
                    scene.add(b); blocks.push(b);
                } else if (intersect.object.position.y !== 0) {
                    scene.remove(intersect.object);
                    blocks.splice(blocks.indexOf(intersect.object), 1);
                }
            }
        };
        document.getElementById('btn-add').addEventListener('touchstart', (e) => { e.preventDefault(); handleBlock('add'); });
        document.getElementById('btn-rem').addEventListener('touchstart', (e) => { e.preventDefault(); handleBlock('rem'); });

        // --- メインループ ---
        const speed = 0.1;
        function animate() {
            requestAnimationFrame(animate);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            dir.y = 0; dir.normalize();
            const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

            if (move.f) camera.position.addScaledVector(dir, speed);
            if (move.b) camera.position.addScaledVector(dir, -speed);
            if (move.l) camera.position.addScaledVector(side, speed);
            if (move.r) camera.position.addScaledVector(side, -speed);

            renderer.render(scene, camera);
        }
        animate();

        // 画面サイズ変更対応
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
